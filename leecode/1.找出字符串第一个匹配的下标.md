# [力扣28](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150)

给你两个字符串 `haystack` 和 `needle`，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标(下标从 0 开始)。如果 `needle` 不是 `haystack` 的一部分，则返回 -1 。

示例 1：

输入: `haystack` = "sadbutsad", `needle` = "sad"

输出：0

解释："sad" 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。

示例 2:

输入: `haystack` = "leetcode", `needle` = "leeto"

输出： -1

解释: "leeto" 没有在 "leetcode" 中出现，所以返回 -1。

提示：

-  $1<=$  `haystack`.length, `needle`.length $<=10^{4}$
- `haystack` 和 `needle` 仅由小写英文字符组成

## 对于朴素写法为：

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        n = len(haystack)
        m = len(needle)
        for i in range(n):
            if i+m<=n:
                window = haystack[i:i+m]
                if window == needle:
                    return i
        return -1
```
时间复杂度：O(m*n)

空间复杂度：O(1)


## 改造为双指针的形式,为了方便KMP的编写：
```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        n = len(haystack)
        m = len(needle)
        i,j = 0,0
        while i<n:
            if haystack[i] == needle[j]:
                i += 1
                j += 1
                if j == m:
                    return i-j
            else:
                i = i-j+1
                j = 0
        return -1
```

## KMP版本：
```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        n = len(haystack)
        m = len(needle)
        i = j = 0

        def longest_length_of_prefix_and_suffix(substr):
            n = len(substr)
            if n == 1:
                return 0
            num = 0
            for i in range(n-1):
                if substr[:n-i-1] == substr[i+1:]:
                    num = len(substr[i+1:])
                    break
            return num

        def getnext(needle):
            m = len(needle)
            next = [0]*m
            if m == 1:
                next = [0]
            elif m == 2:
                next = [0,1]
            else:
                next[1] = 1
                for i in range(2,m):
                    next[i] = longest_length_of_prefix_and_suffix(needle[0:i])+1
            return next

        next = getnext(needle)

        while i < n:
            if haystack[i] == needle[j]:
                i += 1
                j += 1
                if j == m:
                    return i - j
            else:
                if j > 0:
                    j = next[j]-1
                else:
                    i += 1
                    j = 0
        return -1
```
时间复杂度：O(m+n)

空间复杂度：O(m) , m为`needle`的长度





## KMP优化版本('史山',但好理解)：

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        n = len(haystack)
        m = len(needle)
        i = j = 0

        def longest_length_of_prefix_and_suffix(substr):
            n = len(substr)
            if n == 1:
                return 0
            num = 0
            for i in range(n-1):
                if substr[:n-i-1] == substr[i+1:]:
                    num = len(substr[i+1:])
                    break
            return num

        def getnext(needle):
            m = len(needle)
            next = [0]*m
            if m == 1:
                next = [0]
            elif m == 2:
                next = [0,1]
            else:
                next[1] = 1
                for i in range(2,m):
                    next[i] = longest_length_of_prefix_and_suffix(needle[0:i])+1
            return next

        next = getnext(needle)
 
        def getnextval(needle,next):
            nextval = next
            for i in range(1,len(next)):
                if needle[i] == needle[next[i]-1]:
                    nextval[i] = next[next[i]-1]
            return nextval
        
        nextval = getnextval(needle,next)

        while i < n:
            if haystack[i] == needle[j]:
                i += 1
                j += 1
                if j == m:
                    return i - j
            else:
                if j > 0:
                    j = nextval[j]-1
                else:
                    i += 1
                    j = 0
        return -1
```



## 终极版本(修改代码结构,看起来更漂亮)：

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        n = len(haystack)
        m = len(needle)

        next = [0] * m
        j = 0
        for i in range(1, m):
            while j > 0 and needle[i] != needle[j]:
                j = next[j - 1]
            if needle[i] == needle[j]:
                j += 1
            next[i] = j

        i = j = 0
        while i < n:
            if haystack[i] == needle[j]:
                i += 1
                j += 1
                if j == m:
                    return i - j
            else:
                if j > 0:
                    j = next[j - 1]
                else:
                    i += 1
        
        return -1

```














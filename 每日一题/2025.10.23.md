# 3461. 判断操作后字符串中的数字是否相等 I

## 题目描述

给你一个由数字组成的字符串 `s`，重复执行以下操作，直到字符串恰好包含 **两个数字**：



1. 从第一个数字开始，对 `s` 中的每一对连续数字，计算这两个数字的和 **模 10**；

2. 用计算得到的新数字依次替换 `s` 的每一个字符，并保持原本的顺序。

若最终剩下的两个数字 **相同**，返回 `true`；否则，返回 `false`。

## 示例

### 示例 1



* **输入**：`s = "3902"`

* **输出**：`true`

* **解释**：

1. 初始 `s = "3902"`（长度 4）；

2. 第一次操作：

* (3 + 9) % 10 = 2，(9 + 0) % 10 = 9，(0 + 2) % 10 = 2；

* `s` 变为 `"292"`（长度 3）；

1. 第二次操作：

* (2 + 9) % 10 = 1，(9 + 2) % 10 = 1；

* `s` 变为 `"11"`（长度 2）；

1. 最终两个数字相同，返回 `true`。

### 示例 2



* **输入**：`s = "34789"`

* **输出**：`false`

* **解释**：

1. 初始 `s = "34789"`（长度 5）；

2. 第一次操作后 `s = "7157"`（长度 4）；

3. 第二次操作后 `s = "862"`（长度 3）；

4. 第三次操作后 `s = "48"`（长度 2）；

5. 最终两个数字不同，返回 `false`。

## 提示



* `3 <= s.length <= 100`

* `s` 仅由数字组成（字符形式，如 `"3"` 对应数字 3）






***
***




## 解题思路

你的解法采用 “模拟操作过程” 的思路，直接按照题目描述的规则循环处理字符串，直到长度为 2 后判断结果，逻辑直观且贴合题意，具体拆解如下：

### 核心逻辑：循环模拟操作过程



1. **循环条件**：只要当前字符串 `s` 的长度大于 2，就继续执行操作；

2. **单次操作步骤**：

* 初始化空字符串 `new_s`，用于存储操作后的新字符串；

* 用双指针（`p1` 和 `p2 = p1 + 1`）遍历原字符串的每一对连续字符：


  * 将 `s[p1]` 和 `s[p2]` 转换为整数，计算 `(和) % 10`；

  * 将结果转换为字符串，追加到 `new_s` 中；

  * 移动 `p1` 至下一个位置（`p1 += 1`），继续处理下一对连续字符；

* 用 `new_s` 替换原字符串 `s`（此时 `s` 的长度比之前减少 1）；

1. **终止判断**：当 `s` 的长度为 2 时，循环结束，判断两个字符是否相同（`s[0] == s[1]`），返回结果。

## 代码实现（带注释）



```
class Solution:

&#x20;   def hasSameDigits(self, s: str) -> bool:

&#x20;       # 循环执行操作，直到字符串长度为2

&#x20;       while len(s) > 2:

&#x20;           new\_s = ''  # 存储操作后的新字符串

&#x20;           p1 = 0      # 双指针的第一个指针（指向当前数字）

&#x20;           # 遍历所有连续数字对（p1 从0到len(s)-2）

&#x20;           while p1 < len(s) - 1:

&#x20;               p2 = p1 + 1  # 第二个指针（指向后一个数字）

&#x20;               # 计算两数字的和模10，转换为字符串追加到new\_s

&#x20;               new\_s += str((int(s\[p1]) + int(s\[p2])) % 10)

&#x20;               p1 += 1  # 移动到下一对

&#x20;           s = new\_s  # 更新字符串为操作后的结果

&#x20;       # 最终判断两个数字是否相同

&#x20;       return s\[0] == s\[1]
```

## 时空复杂度分析

### 1. 时间复杂度：O (n²)



* 符号定义：`n` 为初始字符串 `s` 的长度（`3 ≤ n ≤ 100`）。

* 分析：


  * 外层循环次数：每次操作后字符串长度减少 1，从 `n` 减到 2，共需 `n-2` 次循环；

  * 内层循环次数：第 `i` 次外层循环时，字符串长度为 `n - (i-1)`，内层需遍历 `(长度 - 1)` 对连续数字，总操作次数为 `(n-1) + (n-2) + ... + 2`（从长度 `n` 到 3，每次内层循环次数为长度 - 1）；

  * 总和为等差数列求和：`(n-1 + 2) * (n-2) / 2 = (n+1)(n-2)/2`，复杂度为 O (n²)，在 `n ≤ 100` 时运算量极小（最大约 5000 次操作），效率足够。

### 2. 空间复杂度：O (n)

























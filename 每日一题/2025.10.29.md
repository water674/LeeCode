# 3370. 仅含置位位的最小整数
><span style="color:rgb(76,175,79)">简单</span>
## 题目描述

给你一个正整数 `n`，返回 **大于等于&#x20;**`n`**&#x20;且二进制表示仅包含置位位的最小整数&#x20;**`x`。

**置位位**：指二进制表示中值为 1 的位（即二进制数仅由 1 组成，如 `1`（二进制 `1`）、`3`（二进制 `11`）、`7`（二进制 `111`）等）。

## 示例

### 示例 1



* **输入**：`n = 5`

* **输出**：`7`

* **解释**：5 的二进制为 `101`（含非置位位 0），大于等于 5 且仅含置位位的最小整数是 7（二进制 `111`）。

### 示例 2



* **输入**：`n = 10`

* **输出**：`15`

* **解释**：10 的二进制为 `1010`（含非置位位 0），大于等于 10 且仅含置位位的最小整数是 15（二进制 `1111`）。

### 示例 3



* **输入**：`n = 3`

* **输出**：`3`

* **解释**：3 的二进制为 `11`（仅含置位位），本身已满足条件，故返回 3。

## 提示



* `1 <= n <= 1000`
















***
***





















## 解法一：找规律

### 解题思路

- **关键观察**：若 n 的二进制有 k 位，则 “k 位全 1 的二进制数”（对应十进制 2^k - 1）是 “大于等于 n 的最小全 1 数”。
     - 例：n=5（二进制 101，3 位）→ 3 位全 1 二进制数是 111（十进制 7），即 2³-1=7，恰好是满足条件的结果；
     - 例：n=10（二进制 1010，4 位）→ 4 位全 1 二进制数是 1111（十进制 15），即 2⁴-1=15，符合结果；
     - 例：n=3（二进制 11，2 位）→ 2 位全 1 二进制数是 11（十进制 3），本身满足条件。
- **实现步骤**：
    - 用右移操作（`n >>= 1`）计算 n 的二进制位数：每次右移 1 位相当于十进制除以 2，直到 n 变为 0，移动的次数即为原 n 的二进制位数 k；
    - 用累加 2 的幂次（`res += 2^i`）构造 “k 位全 1 的十进制数”：i 从 0 开始递增，累加 2⁰、2¹、2²…2^(k-1)，总和恰好是 2^k - 1（即 k 位全 1 的十进制值）。

### 代码实现



```python
class Solution:
    def smallestNumber(self, n: int) -> int:
        res = 0
        i = 0
        while n!= 0:
            n >>= 1
            res += 2**i
            i += 1
        return res
```

### 代码执行示例（以 n=5 为例）

- 初始状态：res=0，i=0，n=5；
- 第一次循环：n>>=1 → n=2（5//2=2），res += 2⁰ → res=1，i=1；
- 第二次循环：n>>=1 → n=1（2//2=1），res += 2¹ → res=1+2=3，i=2；
- 第三次循环：n>>=1 → n=0（1//2=0），res += 2² → res=3+4=7，i=3；
- 循环结束，返回 res=7（符合预期结果）。

### 时空复杂度分析

- 时间复杂度：O (log n)
    - 分析：循环次数取决于 n 的二进制位数，而 n 的二进制位数为 log₂n + 1（如 n=5，log₂5≈2.32，位数为 3），因此循环执行次数为 O (log n)；
- 空间复杂度：O (1)

# 3217. 从链表中移除在数组中存在的节点
><span style="color:rgb(251,193,45)">中等</span>
## 题目描述

给你一个整数数组 `nums` 和一个链表的头节点 `head`。从链表中移除所有**值存在于&#x20;**`nums`**&#x20;中的节点**后，返回修改后的链表的头节点。

## 示例

### 示例 1



* **输入**：`nums = [1,2,3]`，`head = [1,2,3,4,5]`（链表结构：1 → 2 → 3 → 4 → 5）

* **输出**：`[4,5]`（链表结构：4 → 5）

* **解释**：移除链表中值为 1、2、3 的节点，剩余节点为 4 和 5。

### 示例 2



* **输入**：`nums = [1]`，`head = [1,2,1,2,1,2]`（链表结构：1 → 2 → 1 → 2 → 1 → 2）

* **输出**：`[2,2,2]`（链表结构：2 → 2 → 2）

* **解释**：移除链表中所有值为 1 的节点，剩余节点均为 2。

### 示例 3



* **输入**：`nums = [5]`，`head = [1,2,3,4]`（链表结构：1 → 2 → 3 → 4）

* **输出**：`[1,2,3,4]`（链表结构不变）

* **解释**：链表中不存在值为 5 的节点，无需移除任何节点。

## 提示



1. `1 <= nums.length <= 10^5`

2. `1 <= nums[i] <= 10^5`

3. `nums` 中的所有元素都是唯一的（无重复值）

4. 链表中的节点数在 `[1, 10^5]` 范围内

5. `1 <= Node.val <= 10^5`

6. 输入保证链表中**至少有一个值没有在&#x20;**`nums`**&#x20;中出现过**（即最终链表不为空）



















***
***




## 解法一：虚拟头节点 + 哈希集合 + 单指针遍历


### 解题思路

#### 1. 核心优化：哈希集合加速查询



* **问题**：若直接用数组 `nums` 判断节点值是否需要移除，每次查询的时间复杂度为 O (n)（n 为 `nums` 长度），效率低下；

* **优化**：将 `nums` 转换为哈希集合（`set(nums)`），使查询操作的时间复杂度降至 O (1)，大幅提升效率。

#### 2. 虚拟头节点处理边界情况



* **问题**：若链表的头节点需要被移除，直接操作会丢失新的头节点；

* **解决**：创建虚拟头节点 `dummy`（值为 0，`next` 指向原头节点 `head`），确保无论原头节点是否被移除，都能通过 `dummy.next` 找到新的头节点。

#### 3. 单指针遍历筛选节点



* 使用指针 `cur` 从 `dummy` 开始遍历，同步移动原头指针 `head` 遍历链表：


  * 若当前节点 `head.val` 在哈希集合中（需要移除）：将 `cur.next` 指向 `head.next`（跳过当前节点）；

  * 若当前节点 `head.val` 不在哈希集合中（需要保留）：将 `cur` 移动到 `cur.next`（`cur` 始终指向最后一个保留的节点）；

  * 无论是否移除节点，`head` 都向后移动一位（继续遍历下一个节点）。

* 遍历结束后，`dummy.next` 即为修改后链表的头节点。

### 代码实现（带注释）



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def modifiedList(self, nums: List[int], head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = cur = ListNode(0,head)
        nums = set(nums)
        while head:
            if head.val in nums:
                cur.next = head.next
            else:
                cur = cur.next
            head = head.next
        return dummy.next
```

### 时空复杂度分析

#### 1. 时间复杂度：O (m + n)



* 符号定义：`m` 为数组 `nums` 的长度，`n` 为链表的节点数。

* 分析：


  * 将 `nums` 转为哈希集合：O (m)；

  * 遍历链表：O (n)（每个节点仅访问一次，每次查询集合为 O (1)）；


#### 2. 空间复杂度：O (m)



* 分析：


  * 主要额外空间来自哈希集合 `num_set`，存储了 `nums` 中的所有元素，空间复杂度为 O (m)；

  * 其他变量（`dummy`、`cur`、`head`）均为常数级空间，可忽略；





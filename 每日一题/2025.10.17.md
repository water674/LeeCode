# 3003. 执行操作后的最大分割数量
>困难
## 题目描述

给你一个下标从 0 开始的字符串 `s` 和一个整数 `k`，需执行以下分割操作直到 `s` 为空：



1. 选择 `s` 的**最长前缀**，该前缀最多包含 `k` 个不同字符；

2. 删除这个前缀，分割数量加 1；若有剩余字符，保持原有顺序。

在执行分割操作**之前**，你可以将 `s` 中**至多一处**下标的字符更改为另一个小写英文字母（也可以不修改）。

请在最优选择修改方案的情形下，返回分割操作结束时能得到的**最大分割数量**。

## 示例

### 示例 1



* **输入**：`s = "accca"`，`k = 2`

* **输出**：`3`

* **解释**：

1. 最优修改：将 `s[2]` 改为 `b`，字符串变为 `"acbca"`；

2. 第一次分割：最长前缀 `"ac"`（含 2 个不同字符），删除后 `s` 变为 `"bca"`，分割数 = 1；

3. 第二次分割：最长前缀 `"bc"`（含 2 个不同字符），删除后 `s` 变为 `"a"`，分割数 = 2；

4. 第三次分割：删除剩余 `"a"`，分割数 = 3；

   最终最大分割数量为 3。

### 示例 2



* **输入**：`s = "aabaab"`，`k = 3`

* **输出**：`1`

* **解释**：

1. 原字符串仅含 2 个不同字符，即使修改一处字符，最多仍含 3 个不同字符；

2. 分割时最长前缀为整个字符串，仅需 1 次分割即可删空，故结果为 1。

### 示例 3



* **输入**：`s = "xxyz"`，`k = 1`

* **输出**：`4`

* **解释**：

1. 最优修改：将 `s[0]` 改为 `w`，字符串变为 `"wxyz"`（含 4 个不同字符）；

2. 因 `k=1`，每次仅能分割含 1 个不同字符的最长前缀，需依次分割 `w`、`x`、`y`、`z`，共 4 次；

   最终最大分割数量为 4。

## 提示



* `1 <= s.length <= 10^4`

* `s` 仅包含小写英文字母

* `1 <= k <= 26`








***
***





## 解法一：位运算 + 预处理 + 枚举（[官方题解](https://leetcode.cn/problems/maximize-the-number-of-partitions-after-operations/solutions/3799989/zhi-xing-cao-zuo-hou-de-zui-da-fen-ge-sh-fwni/?envType=daily-question&envId=2025-10-17)）

### 解题思路：

由题设可知，我们能够至多修改一处位置的字符，在不进行修改的情况下，我们能够很轻易地通过遍历字符串来计算出分割的数量以及每一个分割的具体区间。

假设我们修改了位置 `i` 处的字符，易知这个字符一定处于不进行修改的情况下，通过遍历计算出的某一个分割内，这里我们设为第 `t` 个分割。

由于题设中对字符串的分割是从头到尾进行的，因此在第 `t−1` 及以前的分割都是确定的，我们修改第 `i` 位的字符不影响 `t−1` 及以前的分割。

并且容易知道，在不进行修改的情况下，从头到尾遍历字符串进行分割，与从尾到头遍历字符串进行分割，得到的分割数量是相同的。因此我们以从尾到头的视角来看，与以上推论相似的，修改第 `i` 位的字符不影响 `t+1` 及以后的分割。

那么对原字符串做出如下划分：以第 `i` 位为分界，对于左半部分，即第 `0` 位到第 `i−1` 位，我们按照从头到尾的方式进行分割，得到的最后一个分割称为第 `i` 位的左相邻分割，简称为左分割，左分割以前的部分称为前缀分割；而对于右半部分，即第 `i+1` 位到第 `n−1` 位，我们按照从尾到头的方式进行分割，得到的最后一个分割称为第 `i` 位的右相邻分割，简称为右分割，右分割以后的部分称为后缀分割。

于是对于被修改的，位置为 `i` 的字符，我们只需要考虑其对左分割和右分割的影响，分为以下三种情况：



1. 即使修改了位置为 `i` 的字符，左分割、右分割内以及第 `i` 位的不同字符数量仍然不超过 `k`，左分割、右分割以及第 `i` 位合并为一个分割，对答案贡献为 `1`。

2. 左分割的不同字符数量为 `k`，右分割中不同字符数量也为 `k`，并且左分割与右分割中不同字符的数量不超过 `25`，把第 `i` 位修改为左分割、右分割中不包含的字符后，左分割、右分割以及第 `i` 位能够重组为三个分割，对答案贡献为 `3`。

3. 其他情况对答案贡献为 `2`。

那么我们需要统计在位置 `i` 处字符的左分割与右分割所包含的信息，包括：前缀分割与后缀分割中包含的分割数量，左分割与右分割的字符掩码以及左分割与右分割中不同字符数量。

这里使用位运算来表示字符掩码，使用数组 `left` 和 `right` 分别表示左分割和右分割的信息，其中 `left[i]` 和 `right[i]` 分别表示位置 `i` 处字符的左分割与右分割所包含的信息，`left[i][0]` 和 `right[i][0]` 分别表示前缀分割与后缀分割中包含的分割数量，`left[i][1]` 和 `right[i][1]` 分别表示左分割与右分割的字符掩码，`left[i][2]` 和 `right[i][2]` 分别表示左分割与右分割中不同字符数量。

有了以上信息，我们只需要枚举修改的字符，然后取最大分割数即可。


### 代码实现

```python
class Solution:
    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:
        n = len(s)
        left = [[0] * 3 for _ in range(n)]
        right = [[0] * 3 for _ in range(n)]

        num, mask, count = 0, 0, 0
        for i in range(n - 1):
            binary = 1 << (ord(s[i]) - ord("a"))
            if not (mask & binary):
                count += 1
                if count <= k:
                    mask |= binary
                else:
                    num += 1
                    mask = binary
                    count = 1
            left[i + 1][0] = num
            left[i + 1][1] = mask
            left[i + 1][2] = count

        num, mask, count = 0, 0, 0
        for i in range(n - 1, 0, -1):
            binary = 1 << (ord(s[i]) - ord("a"))
            if not (mask & binary):
                count += 1
                if count <= k:
                    mask |= binary
                else:
                    num += 1
                    mask = binary
                    count = 1
            right[i - 1][0] = num
            right[i - 1][1] = mask
            right[i - 1][2] = count

        max_val = 0
        for i in range(n):
            seg = left[i][0] + right[i][0] + 2
            tot_mask = left[i][1] | right[i][1]
            tot_count = bin(tot_mask).count("1")
            if left[i][2] == k and right[i][2] == k and tot_count < 26:
                seg += 1
            elif min(tot_count + 1, 26) <= k:
                seg -= 1
            max_val = max(max_val, seg)
        return max_val

```

### 时空复杂度

- 时间复杂度：O(M \* n)
  - n 为字符串 s 的长度，M 为 26。

- 空间复杂度：O(n)
   - 使用了数组 left 和 right 分别表示左分割与右分割中的信息，两个数组大小正比于 n。













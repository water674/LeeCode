# 2048. 下一个更大的数值平衡数
><span style="color:rgb(251,193,45)">中等</span>
## 题目描述

如果整数 `x` 满足：对于每个数位 `d`，这个数位 **恰好** 在 `x` 中出现 `d` 次，那么整数 `x` 就是一个 **数值平衡数**。

给你一个整数 `n`，请你返回 **严格大于&#x20;**`n`**&#x20;的最小小数值平衡数**。

## 示例

### 示例 1



* **输入**：`n = 1`

* **输出**：`22`

* **解释**：


  * 22 是一个数值平衡数，因为数字 2 出现 2 次；

  * 这是严格大于 1 的最小数值平衡数。

### 示例 2



* **输入**：`n = 1000`

* **输出**：`1333`

* **解释**：


  * 1333 是一个数值平衡数，因为数字 1 出现 1 次，数字 3 出现 3 次；

  * 这是严格大于 1000 的最小数值平衡数；

  * 注意：1022 不能作为答案，因为数字 0 的出现次数超过了 0。

### 示例 3



* **输入**：`n = 3000`

* **输出**：`3133`

* **解释**：


  * 3133 是一个数值平衡数，因为数字 1 出现 1 次，数字 3 出现 3 次；

  * 这是严格大于 3000 的最小数值平衡数。

## 提示



* `0 <= n <= 10^6`



























***
***













## 解法一：枚举暴力

### 解题思路

- **遍历起点**：由于需要 “严格大于 n”，因此从 `n + 1` 开始逐个检查整数（通过 `while True` 循环实现无限遍历，直到找到目标数后终止）；

- **数位计数**：对当前检查的整数 `n`（循环中已自增为 `n+1`、`n+2`...），先将其转换为字符串（方便拆分每个数位），再用 `Counter` 统计每个数位出现的次数（例如 `n=1333` 转换为字符串后，`Counter` 结果为 `{'1':1, '3':3}`）；

- **平衡验证**：遍历 `Counter` 的每个键值对（键为数位字符，值为该数位出现的次数）：
  - 将键（字符类型）转换为整数 `d`（即当前数位），对比其出现次数 `cnt[key]`；
  - 若存在任意一个数位 `d` 的出现次数不等于 `d`（如 `1022` 中数位 0 出现 1 次，1≠0），则当前数不是数值平衡数，标记 `valid=False` 并跳出循环，继续检查下一个数；

- **返回结果**：若当前数通过所有数位的平衡验证（`valid=True`），则该数是严格大于 n 的最小数值平衡数，直接返回。

### 代码实现


```python
from collections import Counter
class Solution:
    def nextBeautifulNumber(self, n: int) -> int:
        while True:
            n += 1
            valid = True
            cnt = Counter(str(n))
            for key in cnt:
                if int(key) != cnt[key]:
                    valid = False
                    break
            if valid:
                return n

```

### 时空复杂度分析

-  时间复杂度：O (M \* K)
  
  - 符号定义：
    - `M`：从 `n+1` 到 “最小数值平衡数” 的整数个数（即遍历的次数，取决于 n 的大小和数值平衡数的分布）；
    - `K`：遍历过程中每个整数的位数（例如 n=1000 时，检查的数多为 4 位数，K=4；n=10^6 时，检查的数多为 7 位数，K=7）。
  
  - 分析：
    - 遍历次数 `M`：数值平衡数并非稀疏分布（例如 1-10^7 范围内的数值平衡数包括 1、22、122、212、221、333、1333、3133、3313、3331、4444 等）；
    - 单次遍历耗时：对每个数，`Counter(str(n))` 需遍历其所有数位（耗时 O (K)），验证环节也需遍历所有不同数位（最多 10 个，耗时 O (1)，可忽略），因此单次遍历耗时近似 O (K)；
    - 总时间复杂度：O (M \* K)，在题目约束下，实际运行效率极高，无超时风险。

- 空间复杂度：O (1)
  - 额外空间主要来自 `Counter` 对象，用于存储当前数的数位计数结果。由于数位仅为 0-9 这 10 种可能，`Counter` 最多存储 10 个键值对，空间占用为常数；















# 1625. 执行操作后字典序最小的字符串
><span style="color:rgb(251,193,45)">中等</span>
## 题目描述

给你一个字符串 `s` 以及两个整数 `a` 和 `b`。其中，字符串 `s` 的长度为偶数，且仅由数字 0 到 9 组成。

你可以在 `s` 上按任意顺序多次执行下面两个操作之一：



1. **累加**：将 `a` 加到 `s` 中所有下标为奇数的元素上（下标从 0 开始）。当数字超过 9 时，从 0 重新循环计算。例如，`s = "3456"` 且 `a = 5`，执行此操作后 `s` 变成 `"3951"`。

2. **轮转**：将 `s` 向右轮转 `b` 位。例如，`s = "3456"` 且 `b = 1`，执行此操作后 `s` 变成 `"6345"`。

请你返回在 `s` 上执行上述操作任意次后可以得到的**字典序最小的字符串**。

**字典序定义**：如果两个字符串长度相同，字符串 `a` 字典序比字符串 `b` 小，当且仅当在 `a` 和 `b` 出现不同的第一个位置上，`a` 中的字符出现在字母表中（此处指数字顺序）的时间早于 `b` 中的对应字符。例如，`"0158"` 字典序比 `"0190"` 小（第三个字符 `'5' < '9'`）。

## 示例

### 示例 1



* **输入**：`s = "5525"`, `a = 9`, `b = 2`

* **输出**：`"2050"`

* **解释**：

1. 初态：`"5525"`

2. 轮转：`"2555"`

3. 累加：`"2454"`

4. 累加：`"2353"`

5. 轮转：`"5323"`

6. 累加：`"5222"`

7. 累加：`"5121"`

8. 轮转：`"2151"`

9. 累加：`"2050"`

10. 无法获得字典序更小的字符串，故返回 `"2050"`。

### 示例 2



* **输入**：`s = "74"`, `a = 5`, `b = 1`

* **输出**：`"24"`

* **解释**：

1. 初态：`"74"`

2. 轮转：`"47"`

3. 累加：`"42"`（奇数下标元素 `7 + 5 = 12 → 2`）

4. 轮转：`"24"`

5. 无法获得字典序更小的字符串，故返回 `"24"`。

### 示例 3



* **输入**：`s = "0011"`, `a = 4`, `b = 2`

* **输出**：`"0011"`

* **解释**：执行任何操作都无法得到字典序更小的字符串。

## 提示



* `2 <= s.length <= 100`（字符串长度为偶数）

* `s` 仅由数字 `0-9` 组成

* `1 <= a <= 9`

* `1 <= b <= s.length - 1`

















***
***










## 解法一：广度优先搜索（BFS）+ 状态去重

### 解题思路

- 核心思想：BFS 遍历所有可达状态
    - **BFS 优势**：BFS 能按 “操作步数” 逐层遍历所有可能生成的字符串，确保每个状态只被处理一次，避免遗漏；
    - **状态去重**：用集合`visited`存储已处理过的字符串，防止同一字符串被重复加入队列，减少冗余计算；
    - **最优更新**：用变量`best`实时记录当前遍历到的字典序最小字符串，每处理一个新状态就与`best`比较，更新最小值。

- 具体实现步骤
    - 初始化变量
        - `n = len(s)`：获取字符串长度（题目已说明为偶数）；
        - `visited = set()`：初始化空集合，用于存储已处理的字符串状态；
        - `queue = [s]`：初始化 BFS 队列，起始状态为原始字符串`s`；
        - `visited.add(s)`：将原始字符串加入集合，标记为已处理；
        - `best = s`：初始化最优结果为原始字符串，后续逐步更新。
    - BFS 主循环：处理队列中的每个状态。循环弹出队列头部的字符串`curr`，对其执行 “累加” 和 “轮转” 两种操作，生成新状态并处理：

    - 操作 1：累加（处理奇数下标数字）
        - **逻辑**：遍历字符串所有**奇数下标**（从 1 开始，步长 2），将对应数字加`a`后对 10 取模（处理数字超过 9 的循环情况）；
        - **实现步骤**：
            - 将字符串`curr`转为列表`add_list`（字符串不可变，列表便于修改单个字符）；
            - 遍历奇数下标`i`：`add_list[i] = str((int(add_list[i]) + a) % 10)`；
            - 将列表转回字符串`add_str`；
            - 若`add_str`未在`visited`中，标记为已处理（加入`visited`）并加入队列，等待后续处理。
    - 操作 2：轮转（右轮转 b 位）
        - **逻辑**：右轮转`b`位等价于 “取字符串最后`b`个字符作为前缀，剩余字符作为后缀”（例：`curr="3456"`，`b=1` → 最后 1 个字符 "6" 为前缀，剩余 "345" 为后缀 → "6345"）；
        - **实现步骤**：
            - 切片生成新字符串`rotate_str = curr[-b:] + curr[:-b]`（`curr[-b:]`取最后 b 个字符，`curr[:-b]`取前 n-b 个字符）；
            - 若`rotate_str`未在`visited`中，标记为已处理并加入队列。



### 代码实现

```python
from math import gcd

class Solution:
    def findLexSmallestString(self, s: str, a: int, b: int) -> str:
        n = len(s)
        visited = set()
        queue = [s]
        visited.add(s)
        best = s
        
        while queue:
            curr = queue.pop(0)
            if curr < best:
                best = curr
            
            # 操作1: 累加
            add_list = list(curr)
            for i in range(1, n, 2):
                add_list[i] = str((int(add_list[i]) + a) % 10)
            add_str = ''.join(add_list)
            if add_str not in visited:
                visited.add(add_str)
                queue.append(add_str)
            
            # 操作2: 轮转
            rotate_str = curr[-b:] + curr[:-b]
            if rotate_str not in visited:
                visited.add(rotate_str)
                queue.append(rotate_str)
        
        return best
```


### 时空复杂度分析

- 时间复杂度：O (n \* 10^(n/2))

* **状态总数上限**：字符串每个位置的数字有 10 种可能（0-9），但受操作限制，实际可达状态远少于 10^n。由于 “累加” 仅影响奇数下标，奇数下标最多有 10 种不同状态（加 a 取模 10，循环周期最大为 10），偶数下标状态由 “轮转” 决定，因此状态总数上限可简化为 O (n \* 10^(n/2))（n 为字符串长度，10^(n/2) 为奇数下标的可能状态数，n 为轮转带来的不同排列数）；

* **单个状态处理时间**：每个状态处理时，“累加” 操作遍历 n/2 个奇数下标（O (n)），“轮转” 操作切片为 O (n)，因此单个状态处理时间为 O (n)；

* **总时间**：状态总数 \* 单个状态处理时间 = O (n \* 10^(n/2))。结合题目约束`n ≤ 100`，看似庞大，但实际因`visited`去重和操作的循环性，实际运行中状态数会大幅减少，可高效通过测试用例。

- 空间复杂度：O (n)



* **主要空间开销**：`visited`集合和`queue`队列存储的状态数，与时间复杂度中的 “状态总数” 一致，即 O (n \* 10^(n/2))；

* **其他空间**：处理单个状态时的列表`add_list`占用 O (n) 空间，可忽略不计。












# 1526. 形成目标数组的子数组最少增加次数
><span style="color:rgb(230,73,25)">困难</span>
## 题目描述

给你一个整数数组 `target` 和一个初始数组 `initial`，`initial` 与 `target` 维度相同，且初始时所有元素均为 0。

请你返回从 `initial` 得到 `target` 的**最少操作次数**，每次操作需遵循以下规则：



* 在 `initial` 中选择**任意子数组**，并将子数组中每个元素增加 1。

答案保证在 32 位有符号整数以内。

## 示例

### 示例 1



* **输入**：`target = [1,2,3,2,1]`

* **输出**：`3`

* **解释**：

1. 初始 `initial = [0,0,0,0,0]`，选择下标 0 到 4 的子数组加 1 → `[1,1,1,1,1]`；

2. 选择下标 1 到 3 的子数组加 1 → `[1,2,2,2,1]`；

3. 选择下标 2 的子数组（单个元素）加 1 → `[1,2,3,2,1]`（目标数组）；

   共需 3 次操作。

### 示例 2



* **输入**：`target = [3,1,1,2]`

* **输出**：`4`

* **解释**：

1. `[0,0,0,0]` → 选择下标 0 到 3 加 1 → `[1,1,1,1]`；

2. 选择下标 3 加 1 → `[1,1,1,2]`；

3. 选择下标 0 加 1 → `[2,1,1,2]`；

4. 选择下标 0 加 1 → `[3,1,1,2]`（目标数组）；

   共需 4 次操作。

### 示例 3



* **输入**：`target = [3,1,5,4,2]`

* **输出**：`7`

* **解释**：

1. `[0,0,0,0,0]` → 下标 0 到 4 加 1 → `[1,1,1,1,1]`；

2. 下标 0 加 1 → `[2,1,1,1,1]`；

3. 下标 0 加 1 → `[3,1,1,1,1]`；

4. 下标 2 到 4 加 1 → `[3,1,2,2,2]`；

5. 下标 2 到 3 加 1 → `[3,1,3,3,2]`；

6. 下标 2 到 3 加 1 → `[3,1,4,4,2]`；

7. 下标 2 加 1 → `[3,1,5,4,2]`（目标数组）；

   共需 7 次操作。

### 示例 4



* **输入**：`target = [1,1,1,1]`

* **输出**：`1`

* **解释**：选择下标 0 到 3 的子数组加 1，1 次操作即可得到目标数组。

## 提示



* `1 <= target.length <= 10^5`（数组长度可能较大，解法需考虑时间效率）

* `1 <= target[i] <= 10^5`（元素值范围较大，需避免暴力模拟）






























***
***








## 解法一：爬坡


### 解题思路

- 核心原理：把 `target` 数组看作一个 “直方图”，每个元素的值是对应位置的 “高度”。每次 “子数组加 1” 操作，相当于在直方图中选择一个连续区间，给这个区间的 “高度” 整体加 1。要从全零（高度 0）达到目标高度，最少操作次数的本质是：
    - 对于每个位置，**比前一个位置高的部分**，必须通过 “仅覆盖当前及后续位置的子数组操作” 来补充（前一个位置的高度已通过更早的操作完成，无法再通过覆盖前一个位置的操作补充当前的增量）；
    - 比前一个位置低或相等的部分，无需额外操作（可通过 “不包含当前位置的子数组操作” 来匹配前一个位置的高度，或直接继承前一个位置的操作成果）。

- 例如：`target = [1,2,3,2,1]`，相邻差值分别为 `1-0=1`、`2-1=1`、`3-2=1`、`2-3=-1`、`1-2=-1`、`0-1=-1`（补零后），上升差值之和为 `1+1+1=3`，与示例 1 的答案一致。



### 代码实现



```python
class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        ans = target[0]
        for i in range(1,len(target)):
            if target[i] > target[i-1]:
                ans += target[i] - target[i-1]
        return ans
```



### 时空复杂度分析

- 时间复杂度：O (n)
    - `n` 为原 `target` 数组的长度。
- 空间复杂度：可优化至 O (1)












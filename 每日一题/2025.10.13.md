# 2273. 移除字母异位词后的结果数组

><span style="color:rgb(76,175,79)">简单</span>

## 题目描述

给你一个下标从 **0** 开始的字符串数组 `words`，其中 `words[i]` 由小写英文字符组成。

在一步操作中，需要选出任一下标 `i`，从 `words` 中删除 `words[i]`。其中下标 `i` 需要同时满足下述两个条件：



1. `0 < i < words.length`

2. `words[i - 1]` 和 `words[i]` 是 **字母异位词**

只要可以选出满足条件的下标，就一直执行这个操作。在执行所有操作后，返回 `words`。可以证明，按任意顺序为每步操作选择下标都会得到相同的结果。

**字母异位词**：由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。例如，`"dacb"` 是 `"abdc"` 的一个字母异位词。

## 示例

### 示例 1



* 输入：`words = ["abba","baba","bbaa","cd","cd"]`

* 输出：`["abba","cd"]`

* 解释：

1. 由于 `words[2] = "bbaa"` 和 `words[1] = "baba"` 是字母异位词，删除 `words[2]`，此时 `words = ["abba","baba","cd","cd"]`。

2. 由于 `words[1] = "baba"` 和 `words[0] = "abba"` 是字母异位词，删除 `words[1]`，此时 `words = ["abba","cd","cd"]`。

3. 由于 `words[2] = "cd"` 和 `words[1] = "cd"` 是字母异位词，删除 `words[2]`，此时 `words = ["abba","cd"]`。

4. 无法再执行任何操作，最终结果为 `["abba","cd"]`。

### 示例 2



* **输入**：`words = ["a","b","c","d","e"]`

* **输出**：`["a","b","c","d","e"]`

* **解释**：数组中不存在互为字母异位词的相邻字符串，无需执行任何操作。

## 提示



* `1 <= words.length <= 100`

* `1 <= words[i].length <= 10`

* `words[i]` 由小写英文字母组成







***
***








## 解法一：新建结果数组（正向筛选）

### 思路分析

通过维护一个空的结果数组 `ans` 和一个字符频次计数器 `Dict`，遍历原数组时筛选出 “非前序异位词” 的元素，直接加入结果数组：


1. 初始化 `Dict` 为空计数器（记录上一个保留元素的字符频次）、`ans` 为空结果数组；

2. 遍历原数组 `words` 中的每个元素 `words[i]`：

* 用 `collections.Counter(words[i])` 统计当前元素的字符频次；

* 若当前频次与 `Dict` 相等（说明当前元素是前一个保留元素的异位词），则跳过（不保留）；

* 若不相等（说明当前元素需保留），则更新 `Dict` 为当前元素的频次，同时将当前元素加入 `ans`；

3. 遍历结束后，`ans` 即为最终需保留的数组。

### 代码实现



```python
import collections
class Solution:
    def removeAnagrams(self, words: List[str]) -> List[str]:
        Dict = collections.Counter()
        ans = []
        for i in range(len(words)):
            if collections.Counter(words[i]) == Dict:
                continue
            else:
                Dict = collections.Counter(words[i])
                ans.append(words[i])
        return ans
```

### 时空复杂度



* **时间复杂度**：O(n\* k)


  * n 是原数组 `words` 的长度（遍历数组需 O (n)）；

  * k 是数组中字符串的最大长度（每次用 `Counter` 统计字符频次需 O (k)）；


* **空间复杂度**：O(k)


  * 额外空间主要来自两个 `Counter`，每个计数器最多存储 26 个小写英文字母的频次，空间与字符串长度 k 正相关，故为 O (k)；

  * 结果数组 `ans` 属于 “必要输出空间”，不计入额外空间。



***


## 解法二：原数组原地修改（双指针筛选）

### 思路分析

通过双指针（`i` 为遍历指针，`j` 为保留元素的位置指针）在原数组上原地修改，避免额外创建结果数组，核心是 “将需保留的元素移到数组前部”：



1. 初始化 `Dict` 为空计数器（记录上一个保留元素的字符频次）、`j = 0`（指向当前需填充保留元素的位置）；

2. 遍历原数组（`i` 从 0 到 len (words)-1）：

* 用 `collections.Counter(words[i])` 统计当前元素的字符频次；

* 若当前频次与 `Dict` 相等（当前元素是异位词，不保留），则 `i` 继续后移，`j` 不动；

* 若不相等（当前元素需保留）：

    - 1. 更新 `Dict` 为当前元素的频次；
    
    - 2. 交换 `words[i]` 和 `words[j]`（将需保留的元素移到 `j` 位置）；
    
    - 3. `j` 后移一位（指向 next 需填充的位置）；

3. 遍历结束后，数组前 `j` 个元素即为需保留的结果，返回 `words[:j]`。

### 代码实现



```python
import collections
class Solution:
    def removeAnagrams(self, words: List[str]) -> List[str]:
        Dict = collections.Counter()
        j = 0
        for i in range(len(words)):
            if collections.Counter(words[i]) == Dict:
                continue
            else:
                Dict = collections.Counter(words[i])
                words[i],words[j] = words[j],words[i]
                j += 1
        return words[:j]
```

### 时空复杂度



* **时间复杂度**：O(n \* k)


  * 与解法一一致：遍历数组 O (n)，每次统计字符频次 O (k)，总时间 O (n \* k)。

* **空间复杂度**：O(k)


  * 额外空间仅来自两个 `Counter`，与字符串长度 k 正相关，无其他额外空间（原地修改数组），故为 O (k)。







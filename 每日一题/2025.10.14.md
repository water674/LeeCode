# 3349. 检测相邻递增子数组 I
> 简单
## 题目描述

给你一个由 `n` 个整数组成的数组 `nums` 和一个整数 `k`，请你确定是否存在 **两个相邻且长度为&#x20;**`k`**&#x20;的严格递增子数组**。具体来说，需要检查是否存在从下标 `a` 和 `b`（`a < b`）开始的两个子数组，并满足下述全部条件：



1. 这两个子数组 `nums[a..a + k - 1]` 和 `nums[b..b + k - 1]` 都是 **严格递增** 的（即对于子数组中任意 `i < j`，都有 `nums[i] < nums[j]`）。

2. 这两个子数组必须是 **相邻的**，即 `b = a + k`。

如果可以找到这样的两个子数组，请返回 `true`；否则返回 `false`。

**子数组**：数组中的一个连续非空的元素序列。

## 示例

### 示例 1



* **输入**：`nums = [2,5,7,8,9,2,3,4,3,1]`，`k = 3`

* **输出**：`true`

* **解释**：


  * 从下标 `2` 开始的子数组 `[7, 8, 9]` 是严格递增的。

  * 从下标 `5` 开始的子数组 `[2, 3, 4]` 是严格递增的。

  * 两个子数组相邻（`b = 2 + 3 = 5`），因此结果为 `true`。

### 示例 2



* **输入**：`nums = [1,2,3,4,4,4,4,5,6,7]`，`k = 5`

* **输出**：`false`

* **解释**：数组中不存在满足条件的两个相邻且长度为 `5` 的严格递增子数组。

## 提示



* `2 <= nums.length <= 100`

* `1 <= 2 * k <= nums.length`（保证至少存在两个相邻的长度为 `k` 的子数组）

* `-1000 <= nums[i] <= 1000`

## 解法一：判断每个 2k 长度数组是否满足要求
### 解题思路

采用 “辅助函数判断递增 + 滑动窗口遍历候选片段” 的思路，具体拆解如下：

1. 辅助函数 `increase(arr)`：判断单个数组是否严格递增
- 功能：接收一个子数组 `arr`，返回该数组是否为严格递增数组。
  - 遍历子数组从下标 1 开始的元素（因需与前一个元素比较）；
  - 若存在任意一个元素 `arr[i] <= arr[i-1]`，说明数组非严格递增，返回 `false`；
  - 遍历结束后未发现不满足条件的元素，返回 `true`（数组严格递增）。

2. 主函数 `hasIncreasingSubarrays(nums: List[int], k: int) -> bool`：遍历候选片段并验证

- 特殊情况处理：当 `k = 1` 时，直接返回 `true`。
 - 原因：长度为 1 的子数组本身就是严格递增（无 “前后元素比较” 的不满足场景），且任意两个相邻的长度为 1 的子数组（如 `nums[i]` 和 `nums[i+1]`）天然满足 “相邻” 条件，因此无需额外判断。

- 核心遍历逻辑：
  - 确定遍历范围：需找到长度为 `2k` 的连续片段（前 k 个为第一个子数组，后 k 个为第二个子数组），因此起始下标 `i` 的最大取值为 `len(nums) - 2k`（若 `i` 超过此值，`i+2k` 会超出数组长度），遍历范围设为 `range(len(nums)-2*k+1)`；
  - 提取候选片段：对每个起始下标 `i`，提取 `nums[i:i+2k]` 作为候选片段（总长度 2k）；
  - 验证片段：用辅助函数 `increase` 分别判断候选片段的前 k 个元素（`sub_num[:k]`）和后 k 个元素（`sub_num[k:]`）是否严格递增；
  - 结果判断：若找到任意一个满足 “前 k 个严格递增且后 k 个严格递增” 的片段，立即返回 `true`；遍历结束后未找到，返回 `false`。

### 代码实现
```python
class Solution:
    def increase(self,arr):
        for i in range(1,len(arr)):
            if arr[i] <= arr[i-1]:
                return False
        return True

    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        if k == 1:
            return True
        for i in range(len(nums)-2*k+1):
            sub_num = nums[i:i+2*k]
            if self.increase(sub_num[:k]) and self.increase(sub_num[k:]):
                return True
        return False
```

### 时空复杂度分析

- 时间复杂度：O (n \* k)
  - `n` 为数组 `nums` 的长度；
  - `k` 为子数组长度；

- 空间复杂度：O (k)
  - 辅助函数 `increase` 仅使用遍历变量 `i`，无额外空间开销；
  - 主函数中仅额外存储候选片段 `sub_num`，其长度为 `2k`，空间复杂度为 O (k)；


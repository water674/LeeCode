# 3397. 执行操作后不同元素的最大数量
><span style="color:rgb(251,193,45)">中等</span>
## 题目描述

给你一个整数数组 `nums` 和一个整数 `k`，你可以对数组中的每个元素**最多执行一次**以下操作：将一个在范围 `[-k, k]` 内的整数加到该元素上。

返回执行这些操作后，`nums` 中可能拥有的不同元素的**最大数量**。

## 示例

### 示例 1



* **输入**：`nums = [1,2,2,3,3,4]`，`k = 2`

* **输出**：`6`

* **解释**：

  对前四个元素执行操作后，`nums` 可变为 `[-1, 0, 1, 2, 3, 4]`，此时数组包含 6 个不同元素，达到最大可能值。

### 示例 2



* **输入**：`nums = [4,4,4,4]`，`k = 1`

* **输出**：`3`

* **解释**：

  对 `nums[0]` 加 `-1`、`nums[1]` 加 `1` 后，`nums` 变为 `[3, 5, 4, 4]`，此时数组包含 3 个不同元素，为最大可能值。

## 提示



* `1 <= nums.length <= 10^5`

* `1 <= nums[i] <= 10^9`

* `0 <= k <= 10^9`












***
***






## 解法一：贪心

### 解题思路

- 排序预处理
    - 首先对数组 `nums` 排序，使元素按升序排列。
    -  排序的意义：确保我们可以按顺序处理元素，避免后处理的元素因值过小而无法与先处理的元素区分开，为贪心分配区间提供基础。

- 贪心分配目标值

- 核心思想：对每个元素 `x`，在其可操作的区间 `[x, x + 2*k]` 内（和区间 `[x - k,x + k]`效果一致），选择**最小且大于前一个元素目标值**的数作为当前元素的目标值，这样能为后续元素预留更大的区间，尽可能避免重复。
- 关键操作：
  - 用 `pre` 记录上一个元素的目标值（初始为 `-inf`，表示第一个元素无前置约束）；
  - 对当前元素 `x`，计算其可分配的目标值：
    `x = min(max(x, pre + 1), x + 2*k)`
    解析：
    - `max(x, pre + 1)`：确保当前目标值**大于前一个目标值**（避免重复），且不小于 `x` 可操作的最小值 `x `；
    - `min(..., x + 2*k)`：确保当前目标值不超过 `x` 可操作的最大值 `x + 2*k`；
  - 若计算出的目标值 `x` 大于 `pre`（说明成功分配了一个不重复的目标值），则计数 `ans += 1`，并更新 `pre` 为当前目标值；
  - 若目标值不大于 `pre`（说明当前元素无法分配不重复的目标值），则跳过该元素。


### 代码实现



```python
class Solution:
    def maxDistinctElements(self, nums: List[int], k: int) -> int:
        nums.sort()
        ans = 0
        pre = -inf
        for x in nums:
            x = min(max(x, pre + 1), x + 2*k)
            if x > pre:
                ans += 1
                pre = x
        return ans
```

### 时空复杂度分析

- 时间复杂度：O (n log n)
    - 排序操作是主要时间开销；
- 空间复杂度：O (1)
    - 若忽略排序所需的栈空间，则额外空间复杂度为 O (1)（仅使用 `ans`、`pre` 等变量）；






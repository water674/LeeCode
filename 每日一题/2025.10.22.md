# 3347. 执行操作后元素的最高频率 II
><span style="color:rgb(230,73,25)">困难</span>
## 题目描述

给你一个整数数组 `nums` 和两个整数 `k` 和 `numOperations`。你必须对 `nums` 执行 `numOperations` 次操作，每次操作需满足以下条件：



1. 选择一个下标 `i`，且该下标在之前的操作中**没有被选择过**（每个下标最多被操作一次）；

2. 将 `nums[i]` 增加范围 `[-k, k]` 中的一个整数（即 `nums[i]` 操作后的取值范围为 `[nums[i]-k, nums[i]+k]`，可增加负数、0 或正数）。

在执行完所有操作后，请返回 `nums` 中出现**频率最高**的元素的出现次数（频率指某一元素在数组中出现的次数）。

## 示例

### 示例 1



* **输入**：`nums = [1,4,5]`，`k = 1`，`numOperations = 2`

* **输出**：`2`

* **解释**：

1. 选择下标 1（未操作过），将 `nums[1]` 增加 0，数组变为 `[1, 4, 5]`；

2. 选择下标 2（未操作过），将 `nums[2]` 增加 -1，数组变为 `[1, 4, 4]`；

3. 最终数组中元素 `4` 出现 2 次，为最高频率，故返回 2。

### 示例 2



* **输入**：`nums = [5,11,20,20]`，`k = 5`，`numOperations = 1`

* **输出**：`2`

* **解释**：

1. 选择下标 1（未操作过），将 `nums[1]` 增加 0，数组仍为 `[5, 11, 20, 20]`；

2. 最终数组中元素 `20` 出现 2 次，为最高频率，故返回 2。

## 提示



* `1 <= nums.length <= 10^5`（数组长度较大，需注意解法的时间效率）

* `1 <= nums[i] <= 10^9`（元素取值范围大，需避免直接统计所有可能值）

* `0 <= k <= 10^9`（操作可调整的范围大）

* `0 <= numOperations <= nums.length`（操作次数不超过数组长度，保证每次操作都能选到未操作过的下标）














***
***




## 解法一：排序 + 枚举 + 二分查找（[官方题解](https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-ii/solutions/3803631/zhi-xing-cao-zuo-hou-yuan-su-de-zui-gao-n4uko/?envType=daily-question&envId=2025-10-24)）



### 解题思路


本题是前置题目的数据强化版本，`k`和`nums[i]`的范围从1e5变为1e9，因此无法再如「3346. 执行操作后元素的最高频率 I」中直接将`[nums[i]_{min}, nums[i]_{max}]`作为枚举区间。

仍然考虑枚举`m_i`作为目标众数，前置题目中最多能变`m_i`的元素个数`f_i`的计算公式为：
`f_i = min(r - l + 1, numOperations + count_i)`

由于枚举过程中`numOperations`为常数，若`m_i`不在`nums`中（这是无法直接枚举的原因），则`count_i`恒为0，此时`f_i`的值仅取决于`l`和`r`（即仅取决于`m_i`对应的`nums`的上下界元素是否一致）。

对于`l`和`r`相同的那些`m_i`，可只枚举一次。通过单侧情况分析（如`m_i + k`在排序后`nums`中的边界），可推出：
- 对于任意`m_j ∈ [m_i, m_j)`，有`m_i + k ≤ m_j + k < m_l + k`。
- 结合`m_i + k = nums[r_i]`、`m_j + k = nums[r_j + 1]`的关系，可推导出`nums[r_i] - k ≤ m < nums[r_j + 1] - k`。这意味着对于处于`[nums[r_i] - k, nums[r_j + 1] - k)`区间且不在`nums`中的`m`，只需统计一次答案。同理，需将满足条件的`nums[i] + k`加入候选。

也可将`l`和`r`想象成滑动窗口，其中点是`m_i`，窗口右边界`m_i + k`随`m_i`增加而右移，左边界`m_i - k`同理。仅当`l`和`r`变化时，不在`nums`中的`m_i`对答案的贡献才会变化，因此只需在滑动窗口的临界情况时统计一次答案，即对于每一个`nums[i]`，只需枚举`nums[i]`、`nums[i] - k`和`nums[i] + k`即可。

### 代码实现

```python
class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        nums.sort()
        ans = 0
        num_count = defaultdict(int)
        modes = set()

        def add_mode(value):
            modes.add(value)
            if value - k >= nums[0]:
                modes.add(value - k)
            if value + k <= nums[-1]:
                modes.add(value + k)

        last_num_index = 0
        for i in range(len(nums)):
            if nums[i] != nums[last_num_index]:
                num_count[nums[last_num_index]] = i - last_num_index
                ans = max(ans, i - last_num_index)
                add_mode(nums[last_num_index])
                last_num_index = i

        num_count[nums[last_num_index]] = len(nums) - last_num_index
        ans = max(ans, len(nums) - last_num_index)
        add_mode(nums[last_num_index])

        for mode in sorted(modes):
            l = bisect.bisect_left(nums, mode - k)
            r = bisect.bisect_right(nums, mode + k) - 1
            if mode in num_count:
                temp_ans = min(r - l + 1, num_count[mode] + numOperations)
            else:
                temp_ans = min(r - l + 1, numOperations)
            ans = max(ans, temp_ans)
        
        return ans
```

### 时空复杂度

- 时间复杂度 O(n logn)
  - 排序复杂度
- 空间复杂度 O(n)




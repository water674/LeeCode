# 3347. 执行操作后元素的最高频率 II
><span style="color:rgb(230,73,25)">困难</span>
## 题目描述

给你一个整数数组 `nums` 和两个整数 `k` 和 `numOperations`。你必须对 `nums` 执行 `numOperations` 次操作，每次操作需满足以下条件：



1. 选择一个下标 `i`，且该下标在之前的操作中**没有被选择过**（每个下标最多被操作一次）；

2. 将 `nums[i]` 增加范围 `[-k, k]` 中的一个整数（即 `nums[i]` 操作后的取值范围为 `[nums[i]-k, nums[i]+k]`，可增加负数、0 或正数）。

在执行完所有操作后，请返回 `nums` 中出现**频率最高**的元素的出现次数（频率指某一元素在数组中出现的次数）。

## 示例

### 示例 1



* **输入**：`nums = [1,4,5]`，`k = 1`，`numOperations = 2`

* **输出**：`2`

* **解释**：

1. 选择下标 1（未操作过），将 `nums[1]` 增加 0，数组变为 `[1, 4, 5]`；

2. 选择下标 2（未操作过），将 `nums[2]` 增加 -1，数组变为 `[1, 4, 4]`；

3. 最终数组中元素 `4` 出现 2 次，为最高频率，故返回 2。

### 示例 2



* **输入**：`nums = [5,11,20,20]`，`k = 5`，`numOperations = 1`

* **输出**：`2`

* **解释**：

1. 选择下标 1（未操作过），将 `nums[1]` 增加 0，数组仍为 `[5, 11, 20, 20]`；

2. 最终数组中元素 `20` 出现 2 次，为最高频率，故返回 2。

## 提示



* `1 <= nums.length <= 10^5`（数组长度较大，需注意解法的时间效率）

* `1 <= nums[i] <= 10^9`（元素取值范围大，需避免直接统计所有可能值）

* `0 <= k <= 10^9`（操作可调整的范围大）

* `0 <= numOperations <= nums.length`（操作次数不超过数组长度，保证每次操作都能选到未操作过的下标）














***
***




## 解法一：排序 + 枚举 + 二分查找（[官方题解](https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-ii/solutions/3803631/zhi-xing-cao-zuo-hou-yuan-su-de-zui-gao-n4uko/?envType=daily-question&envId=2025-10-24)）



### 解题思路



### 代码实现

```python
class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        nums.sort()
        ans = 0
        num_count = defaultdict(int)
        modes = set()

        def add_mode(value):
            modes.add(value)
            if value - k >= nums[0]:
                modes.add(value - k)
            if value + k <= nums[-1]:
                modes.add(value + k)

        last_num_index = 0
        for i in range(len(nums)):
            if nums[i] != nums[last_num_index]:
                num_count[nums[last_num_index]] = i - last_num_index
                ans = max(ans, i - last_num_index)
                add_mode(nums[last_num_index])
                last_num_index = i

        num_count[nums[last_num_index]] = len(nums) - last_num_index
        ans = max(ans, len(nums) - last_num_index)
        add_mode(nums[last_num_index])

        for mode in sorted(modes):
            l = bisect.bisect_left(nums, mode - k)
            r = bisect.bisect_right(nums, mode + k) - 1
            if mode in num_count:
                temp_ans = min(r - l + 1, num_count[mode] + numOperations)
            else:
                temp_ans = min(r - l + 1, numOperations)
            ans = max(ans, temp_ans)
        
        return ans
```

### 时空复杂度

- 时间复杂度 O(n logn)
  - 排序复杂度
- 空间复杂度 O(n)




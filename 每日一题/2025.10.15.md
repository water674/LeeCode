# 3350. 检测相邻递增子数组 II
><span style="color:rgb(251,193,45)">中等</span>
## 题目描述

给你一个由 `n` 个整数组成的数组 `nums`，请你找出 `k` 的**最大可能值**，使得存在两个相邻且长度为 `k` 的严格递增子数组。具体来说，需满足以下全部条件：



1. 存在从下标 `a` 和 `b`（`a < b`）开始的两个子数组 `nums[a..a + k - 1]` 和 `nums[b..b + k - 1]`，且两个子数组均为**严格递增**（任意位置 `i < j` 满足 `nums[i] < nums[j]`）；

2. 两个子数组必须**相邻**，即 `b = a + k`。

返回满足条件的 `k` 的最大值。若不存在任何满足条件的 `k`（如数组长度为 2 但不严格递增），则返回 0（根据题目隐含逻辑推导，因最小 `k=1` 需两个相邻子数组，即数组长度至少 2，且 `k=1` 时子数组天然严格递增，故实际场景下返回值不小于 1，需结合具体输入判断）。

## 示例

### 示例 1



* **输入**：`nums = [2,5,7,8,9,2,3,4,3,1]`

* **输出**：`3`

* **解释**：


  * 下标 2 开始的子数组 `[7,8,9]` 严格递增，下标 5 开始的子数组 `[2,3,4]` 严格递增；

  * 两个子数组相邻（`5 = 2 + 3`），且不存在更大的 `k` 满足条件，故最大 `k` 为 3。

### 示例 2



* **输入**：`nums = [1,2,3,4,4,4,4,5,6,7]`

* **输出**：`2`

* **解释**：


  * 下标 0 开始的子数组 `[1,2]` 严格递增，下标 2 开始的子数组 `[3,4]` 严格递增（或其他满足条件的组合）；

  * 不存在长度为 3 的相邻严格递增子数组，故最大 `k` 为 2。

## 提示



* `2 <= nums.length <= 2 * 10^5`（需注意数组长度较大，解法需考虑时间效率）

* `-10^9 <= nums[i] <= 10^9`
















***
***

## 解题思路



### 第一步：构建连续递增长度列表 `k_list`



* **核心目的**：将原数组按 “连续严格递增片段” 拆分，`k_list[i]` 表示第 `i` 个连续严格递增片段的长度。

  例如：若 `nums = [2,5,7,8,9,2,3,4,3,1]`，连续严格递增片段为 `[2,5,7,8,9]`（长度 5）、`[2,3,4]`（长度 3）、`[3]`（长度 1）、`[1]`（长度 1），则 `k_list = [5,3,1,1]`。

* **实现逻辑**：

1. 初始化 `k_list = [1]`（第一个元素本身是长度为 1 的连续递增片段）、`k_max = 1`（初始最大 k 值为 1，因最小 k=1 必然满足条件，除非数组长度为 2 且不递增）；

2. 从下标 1 开始遍历原数组 `nums`：

* 若 `nums[i] > nums[i-1]`：当前元素属于上一个连续递增片段，将 `k_list` 最后一个元素加 1（延长上一片段长度）；

* 若 `nums[i] <= nums[i-1]`：当前元素开启新的连续递增片段，在 `k_list` 末尾添加 1（新片段初始长度为 1）。

### 第二步：分场景计算最大 k 值

根据 `k_list` 的长度（即连续递增片段的数量），分两种场景计算最大 k：

#### 场景 1：`len(k_list) == 1`（整个数组是一个连续严格递增片段）



* **逻辑推导**：此时需从 “单个连续递增片段” 中拆分出两个相邻且长度为 k 的子数组，因此片段总长度需 ≥ 2k（即 k ≤ 片段长度 //2）。

  例如：片段长度为 5，最大 k 为 5//2 = 2？不对，实际可拆分为 `[2,5,7]`（k=3）和 `[8,9]`（k=2）？不，正确逻辑是 “单个片段中取两个相邻子数组，总长度 2k ≤ 片段长度”，因此最大 k 为 **片段长度 //2**。

  例：片段长度 5，最大 k=5//2=2？不对，实际片段长度 5 可拆分为前 3 个元素和后 2 个元素（k=2 时总长度 4≤5），但 k=3 时总长度 6>5，因此最大 k=2？不，重新看：若片段长度为 5，能取到的最大 k 是 2 吗？不，若片段长度为 5，可拆分为 `[a0,a1,a2]`（k=3）和 `[a3,a4]`（k=2）？不对，相邻子数组要求第二个子数组起始下标 = 第一个 +k，即第一个子数组是 `[a0,a1,...,a(k-1)]`，第二个是 `[ak,a(k+1),...,a(2k-1)]`，因此 2k ≤ 片段长度，故最大 k = 片段长度 //2。

  例如：片段长度 5，最大 k=5//2=2（2k=4≤5）；片段长度 6，最大 k=3（2k=6≤6）。

* **操作**：返回 `k_list[-1]//2`（即单个片段长度的一半取整）。

#### 场景 2：`len(k_list) ≥ 2`（存在多个连续递增片段）



* **核心逻辑**：最大 k 可能来自两种情况，需取三者中的最大值：

1. 初始 `k_max=1`（保底值）；

2. **跨片段的最大 k**：两个相邻片段（第 j 个和第 j-1 个）中，能取到的最大 k 为 `min(k_list[j], k_list[j-1])`—— 因为需从两个片段中各取长度为 k 的子数组（第一个片段取末尾 k 个元素，第二个片段取开头 k 个元素），k 不能超过任一片段的长度。

   例如：`k_list[j-1]=5`、`k_list[j]=3`，则跨片段最大 k=min (5,3)=3（第一个片段取末尾 3 个元素，第二个片段取开头 3 个元素，刚好相邻）；

3. **单个片段的最大 k**：每个片段（第 j 个）能取到的最大 k 为 `k_list[j]//2`（同场景 1 逻辑，从单个片段拆分两个相邻子数组），需遍历所有片段取最大值。

* **操作**：遍历 `k_list` 从下标 1 开始的元素，对每个 j，更新 `k_max = max(k_max, min(k_list[j], k_list[j-1]), k_list[j]//2, k_list[j-1]//2)`（注：代码中 `max(k_list[j], k_list[j-1])//2` 等价于分别计算两个片段的 `//2` 再取最大，逻辑一致），最终返回 `k_max`。

## 代码实现

```python
class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        k_list = [1]
        k_max = 1
        for i in range(1,len(nums)):
            if nums[i] > nums[i-1]:
                k_list[-1] += 1
            else:
                k_list.append(1)
        
        if len(k_list) == 1:
            return k_list[-1]//2
        for j in range(1,len(k_list)):
            k_max = max(k_max,min(k_list[j],k_list[j-1]),max(k_list[j],k_list[j-1])//2)
        return k_max
```

## 时空复杂度分析

### 1. 时间复杂度：O (n)



* 符号定义：`n` 为数组 `nums` 的长度。

* 分析：


  * 构建 `k_list`：遍历数组 1 次，耗时 O (n)；

  * 计算最大 k：遍历 `k_list` 1 次，`k_list` 的长度 ≤ n（最坏情况数组完全不递增，`k_list` 长度为 n），耗时 O (n)；

  * 总时间复杂度：O (n) + O (n) = O (n)，完美适配题目中 `n ≤ 2*10^5` 的大数组场景，无超时风险。

### 2. 空间复杂度：O (n)



* 分析：


  * 主要额外空间来自 `k_list`，最坏情况（数组完全不递增，每个元素都是独立片段）`k_list` 长度为 n，空间复杂度 O (n)；

  * 其他变量（`k_max`、`i`、`j` 等）均为常数空间，可忽略；

  * 若数组高度递增（`k_list` 长度很小），空间复杂度会远低于 O (n)，整体空间效率优秀。


















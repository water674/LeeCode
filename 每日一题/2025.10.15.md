# 3350. 检测相邻递增子数组 II
><span style="color:rgb(251,193,45)">中等</span>
## 题目描述

给你一个由 `n` 个整数组成的数组 `nums`，请你找出 `k` 的**最大可能值**，使得存在两个相邻且长度为 `k` 的严格递增子数组。具体来说，需满足以下全部条件：



1. 存在从下标 `a` 和 `b`（`a < b`）开始的两个子数组 `nums[a..a + k - 1]` 和 `nums[b..b + k - 1]`，且两个子数组均为**严格递增**（任意位置 `i < j` 满足 `nums[i] < nums[j]`）；

2. 两个子数组必须**相邻**，即 `b = a + k`。

返回满足条件的 `k` 的最大值。若不存在任何满足条件的 `k`（如数组长度为 2 但不严格递增），则返回 0（根据题目隐含逻辑推导，因最小 `k=1` 需两个相邻子数组，即数组长度至少 2，且 `k=1` 时子数组天然严格递增，故实际场景下返回值不小于 1，需结合具体输入判断）。

## 示例

### 示例 1



* **输入**：`nums = [2,5,7,8,9,2,3,4,3,1]`

* **输出**：`3`

* **解释**：


  * 下标 2 开始的子数组 `[7,8,9]` 严格递增，下标 5 开始的子数组 `[2,3,4]` 严格递增；

  * 两个子数组相邻（`5 = 2 + 3`），且不存在更大的 `k` 满足条件，故最大 `k` 为 3。

### 示例 2



* **输入**：`nums = [1,2,3,4,4,4,4,5,6,7]`

* **输出**：`2`

* **解释**：


  * 下标 0 开始的子数组 `[1,2]` 严格递增，下标 2 开始的子数组 `[3,4]` 严格递增（或其他满足条件的组合）；

  * 不存在长度为 3 的相邻严格递增子数组，故最大 `k` 为 2。

## 提示



* `2 <= nums.length <= 2 * 10^5`（需注意数组长度较大，解法需考虑时间效率）

* `-10^9 <= nums[i] <= 10^9`
















***
***




















## 解法一：求出每一段严格递增保存为k_list,再选取k_list中相邻最小数的最大值

### 解题思路

1.构建连续递增长度列表 `k_list`
- 将原数组按 “连续严格递增片段” 拆分，`k_list[i]` 表示第 `i` 个连续严格递增片段的长度。
   - 例如：若 `nums = [2,5,7,8,9,2,3,4,3,1]`，连续严格递增片段为 `[2,5,7,8,9]`（长度 5）、`[2,3,4]`（长度 3）、`[3]`（长度 1）、`[1]`（长度 1），则 `k_list = [5,3,1,1]`。
- 初始化 `k_list = [1]`（第一个元素本身是长度为 1 的连续递增片段）、`k_max = 1`（初始最大 k 值为 1，因最小 k=1 必然满足条件，除非数组长度为 2 且不递增）；
- 从下标 1 开始遍历原数组 `nums`：
  - 若 `nums[i] > nums[i-1]`：当前元素属于上一个连续递增片段，将 `k_list` 最后一个元素加 1（延长上一片段长度）；
  - 若 `nums[i] <= nums[i-1]`：当前元素开启新的连续递增片段，在 `k_list` 末尾添加 1（新片段初始长度为 1）。

2. 分场景计算最大 k 值
根据 `k_list` 的长度（即连续递增片段的数量），分两种场景计算最大 k：
- 场景 1：`len(k_list) == 1`（整个数组是一个连续严格递增片段）
  - 此时需从 “单个连续递增片段” 中拆分出两个相邻且长度为 k 的子数组，因此片段总长度需 ≥ 2k（即 k ≤ 片段长度 //2）。

- 场景 2：`len(k_list) ≥ 2`（存在多个连续递增片段）
  - 最大 k 可能来自两种情况，需取三者中的最大值：
    - 初始 `k_max=1`（保底值）；
    - **跨片段的最大 k**：两个相邻片段（第 j 个和第 j-1 个）中，能取到的最大 k 为 `min(k_list[j], k_list[j-1])`—— 因为需从两个片段中各取长度为 k 的子数组（第一个片段取末尾 k 个元素，第二个片段取开头 k 个元素），k 不能超过任一片段的长度。
       例如：`k_list[j-1]=5`、`k_list[j]=3`，则跨片段最大 k=min (5,3)=3（第一个片段取末尾 3 个元素，第二个片段取开头 3 个元素，刚好相邻）；
    - **单个片段的最大 k**：每个片段（第 j 个）能取到的最大 k 为 `k_list[j]//2`（同场景 1 逻辑，从单个片段拆分两个相邻子数组），需遍历所有片段取最大值。
    - **操作**：遍历 `k_list` 从下标 1 开始的元素，对每个 j，更新 `k_max = max(k_max, min(k_list[j], k_list[j-1]), k_list[j]//2, k_list[j-1]//2)`（注：代码中 `max(k_list[j], k_list[j-1])//2` 等价于分别计算两个片段的 `//2` 再取最大，逻辑一致），最终返回 `k_max`。
      
### 代码实现

```python
class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        k_list = [1]
        k_max = 1
        for i in range(1,len(nums)):
            if nums[i] > nums[i-1]:
                k_list[-1] += 1
            else:
                k_list.append(1)
        
        if len(k_list) == 1:
            return k_list[-1]//2
        for j in range(1,len(k_list)):
            k_max = max(k_max,min(k_list[j],k_list[j-1]),max(k_list[j],k_list[j-1])//2)
        return k_max
```

### 时空复杂度分析

- 时间复杂度：O (n)
  - 符号定义：`n` 为数组 `nums` 的长度。
  - 分析：
     - 构建 `k_list`：遍历数组 1 次，耗时 O (n)；
     - 计算最大 k：遍历 `k_list` 1 次，`k_list` 的长度 ≤ n（最坏情况数组完全不递增，`k_list` 长度为 n），耗时 O (n)；


- 空间复杂度：O (n)
  - 主要额外空间来自 `k_list`，最坏情况（数组完全不递增，每个元素都是独立片段）`k_list` 长度为 n，空间复杂度 O (n)；



***

## 解法二：滚动数组优化k_list

### 解题思路

大部分同解法一，注意到 `k_list`只需要最多存储两个值，因此只需要代码中细微调整。

### 代码实现

```python
class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        k_list = [1]
        k_max = 1
        for i in range(1,len(nums)):
            if nums[i] > nums[i-1]:
                k_list[-1] += 1
            else:
                k_list.append(1)
                k_list = [k_list[-2],k_list[-1]]
            if len(k_list) == 1:
                k_max = max(k_max,k_list[-1]//2)
            else:
                k_max = max(k_max,min(k_list[-1],k_list[-2]),max(k_list[-1],k_list[-2])//2)
        return k_max
```

### 时空复杂度分析

- 时间复杂度：O (n)

- 空间复杂度：O (1)
  - 主要额外空间来自 `k_list`，最坏情况`k_list` 长度为 2，空间复杂度 O (1)；













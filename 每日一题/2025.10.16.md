# 2598. 执行操作后的最大 MEX
><span style="color:rgb(251,193,45)">中等</span>
## 题目描述

给你一个下标从 0 开始的整数数组 `nums` 和一个整数 `value`。

在一步操作中，你可以对 `nums` 中的任一元素**加上或减去** `value`。例如，若 `nums = [1,2,3]` 且 `value = 2`，可选择 `nums[0]` 减去 `value`，得到 `nums = [-1,2,3]`。

数组的 **MEX（minimum excluded，最小缺失非负整数）** 是指数组中缺失的最小非负整数。例如：



* `[-1,2,3]` 的 MEX 是 0（0 未出现）；

* `[1,0,3]` 的 MEX 是 2（0、1 已出现，2 未出现）。

请返回在执行上述操作**任意次**后，`nums` 能达到的最大 MEX。

## 示例

### 示例 1



* **输入**：`nums = [1,-10,7,13,6,8]`，`value = 5`

* **输出**：`4`

* **解释**：

1. `nums[1]` 加 `value` 两次，`nums` 变为 `[1,0,7,13,6,8]`；

2. `nums[2]` 减 `value` 一次，`nums` 变为 `[1,0,2,13,6,8]`；

3. `nums[3]` 减 `value` 两次，`nums` 变为 `[1,0,2,3,6,8]`。

   最终数组的 MEX 是 4，且 4 是可达到的最大 MEX。

### 示例 2



* **输入**：`nums = [1,-10,7,13,6,8]`，`value = 7`

* **输出**：`2`

* **解释**：

1. `nums[2]` 减 `value` 一次，`nums` 变为 `[1,-10,0,13,6,8]`。

   最终数组的 MEX 是 2，且 2 是可达到的最大 MEX。

## 提示



* `1 <= nums.length, value <= 10^5`

* `-10^9 <= nums[i] <= 10^9`





***
***




## 解法一：余数频次统计

### 解题思路

- 1. 核心规律推导：余数决定可调整的目标值
   - 对任意非负整数`y`，若想通过操作得到`y`，需满足：
   - 存在数组元素`x`，使得`x`模`value`的余数 = `y`模`value`的余数（记为`r`，`0 ≤ r < value`）；
   - 余数`r`在数组中的出现次数，需至少能覆盖`y`所在的 “余数分组”（例如`value=5`，余数`1`的分组包含`1、6、11...`，若余数`1`出现`2`次，则可覆盖`1`和`6`，无法覆盖`11`）。

- 2. 具体解题步骤

   - 步骤 1：统计各余数的出现频次
      - **初始化余数频次数组**：创建长度为`value`的数组`m`，`m[r]`表示 “数组元素模`value`后余数为`r`” 的元素个数（`0 ≤ r < value`），初始值均为 0。
      - **计算余数并更新频次**：遍历数组`nums`，对每个元素`nums[i]`，计算其模`value`的余数（`nums[i] % value`），并将对应`m[r]`加 1。
        （注：Python 中负数模运算结果为非负，如`-10 % 5 = 0`，无需额外处理负余数，直接满足`0 ≤ r < value`的要求）。

   - 步骤 2：定位最小缺失非负整数（最大 MEX）
      - **找到余数频次的最小值**`base`：`base`表示所有余数分组中，能覆盖的 “完整轮次”（每轮包含`0、1、2...value-1`各一个数）的最大数量。例如`value=5`，`m=[2,3,2,2,2]`，`base=2`，表示前 2 轮（`0-4`、`5-9`）中，除余数 1 的分组外，其他分组仅能覆盖 2 个元素。
      - **遍历余数分组找最小缺失值**：对每个余数`r`（`0 ≤ r < value`），若`m[r] == base`，说明该余数分组在`base`轮后无法再覆盖下一个元素（即`r + base * value`），这个值就是数组缺失的最小非负整数，直接返回该值。

### 代码实现

```python
class Solution:
    def findSmallestInteger(self, nums: List[int], value: int) -> int:
        m = [0 for _ in range(value)]
        for i in range(len(nums)):
            nums[i] = nums[i]%value
            m[nums[i]] += 1

        base = min(m)
        for j in range(value):
            if m[j] == base:
                return j + m[j]*value
```

### 示例验证（结合题目示例 1）

以示例 1 `nums = [1,-10,7,13,6,8]`，`value = 5` 为例：

1. **计算余数**：

* `1%5=1`，`-10%5=0`，`7%5=2`，`13%5=3`，`6%5=1`，`8%5=3`；

* 余数频次数组`m = [1,2,1,2,0]`（余数 0：1 个，余数 1：2 个，余数 2：1 个，余数 3：2 个，余数 4：0 个）。

1. **找 base**：`min(m) = 0`（余数 4 的频次为 0）。

2. **定位最小缺失值**：遍历到`j=4`时，`m[4] == 0`，返回`4 + 0*5 = 4`，与示例 1 输出一致。

### 时空复杂度分析

- 时间复杂度：O (n + value)
   - O(n)：遍历数组`nums`计算余数并更新频次，`n`为数组长度；
   - O(value)：初始化余数频次数组、计算`min(m)`、遍历余数分组找结果，均需遍历长度为`value`的数组；
   - 总时间复杂度为`O(n + value)`。

- 空间复杂度：O (value)
   - 仅额外使用长度为`value`的余数频次数组`m`，空间复杂度为`O(value)`；













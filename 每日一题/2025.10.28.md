# 3354. 使数组元素等于零
><span style="color:rgb(76,175,79)">简单</span>
## 题目描述

给你一个整数数组 `nums`。

开始时，选择一个满足 `nums[curr] == 0` 的起始位置 `curr`，并选择一个移动方向：向左或者向右。

此后，你需要重复下面的过程：



1. 如果 `curr` 超过范围 `[0, n - 1]`（`n` 为数组长度），过程结束。

2. 如果 `nums[curr] == 0`，沿当前方向继续移动：若向右移，则递增 `curr`；若向左移，则递减 `curr`。

3. 如果 `nums[curr] > 0`：

* 将 `nums[curr]` 减 1。

* 反转移动方向（向左变向右，反之亦然）。

* 沿新方向移动一步。

如果在结束整个过程后，`nums` 中的所有元素都变为 0，则认为选出的初始位置和移动方向 **有效**。

返回可能的有效选择方案数目。

## 示例

### 示例 1



* **输入**：`nums = [1,0,2,0,3]`

* **输出**：`2`

* **解释**：

  可能的有效选择方案如下：

1. 选择 `curr = 3` 并向左移动：

   过程中数组逐步变化为 `[1,0,2,0,3] → [1,0,1,0,3] → [1,0,1,0,2] → [1,0,0,0,2] → [1,0,0,0,1] → [0,0,0,0,1] → [0,0,0,0,0]`，最终所有元素为 0。

2. 选择 `curr = 3` 并向右移动：

   过程中数组逐步变化为 `[1,0,2,0,3] → [1,0,2,0,2] → [1,0,1,0,2] → [1,0,1,0,1] → [1,0,0,0,1] → [1,0,0,0,0] → [0,0,0,0,0]`，最终所有元素为 0。

### 示例 2



* **输入**：`nums = [2,3,4,0,4,1,0]`

* **输出**：`0`

* **解释**：不存在任何满足条件的初始位置和移动方向组合，使得过程结束后数组所有元素变为 0。

## 提示



* `1 <= nums.length <= 100`

* `0 <= nums[i] <= 100`

* 数组中至少存在一个元素 `i` 满足 `nums[i] == 0`（保证存在初始位置可选）














***
***




















## 解法一：动态维护前缀和`L`与后缀和`R`

### 解题思路

- 变量初始化：前缀和、后缀和与结果计数
    - `ans = 0`：统计有效方案总数；
    - `b = len(nums)`：数组长度，简化后续代码书写；
    - `l = nums[0]`：初始前缀和（从数组开头到第一个位置的和，即`nums[0]`，后续会逐步更新为 “到当前 0 位置左侧的总和”）；
    - `r = sum(nums) - nums[0]`：初始后缀和（数组总和减去前缀和，即`nums[1..b-1]`的和，后续会逐步更新为 “当前 0 位置右侧的总和”）。

- 特殊场景处理：数组长度为 1 且元素为 0
    - 若`b == 1 and nums[0] == 0`：根据题目隐含规则，初始方向可选左或右，直接返回 2（两种方案均有效）。

- 分位置判断：遍历所有值为 0 的位置，计算有效方案
- 将数组分为 “左边界（下标 0）、中间位置（下标 1\~b-2）、右边界（下标 b-1）” 三类位置，分别判断值为 0 时的有效方案数：
    -左边界判断（下标 0，`nums[0] == 0`）
        - 左边界的 “左侧总和`L`” 为 0（无左侧元素），仅需关注右侧总和`r`：
            - 若`r == 0`（右侧无需要归零的元素）：初始方向左 / 右均有效，`ans += 2`；
            - 若`r == 1`（右侧仅 1 个需归零的元素）：仅 1 种方向有效，`ans += 1`；
            - 其他`r`值：无有效方案，不加分。

  -中间位置判断（下标 1\~b-2，遍历每个位置`i`）
      - 动态更新前缀和`l`与后缀和`r`：
      - 遍历前，先将`r -= nums[i]`：因当前位置`i`的元素不属于 “右侧总和”，需从`r`中减去；
      - 若`nums[i] == 0`（当前位置是候选起始点）：
          - 比较`l`（左侧总和，`nums[0..i-1]`的和）与`r`（右侧总和，`nums[i+1..b-1]`的和）；
          - 若`l == r`：贡献 2 种方案，`ans += 2`；
          - 若`abs(l - r) == 1`：贡献 1 种方案，`ans += 1`；
      - 遍历后，将`l += nums[i]`：将当前位置`i`的元素加入前缀和，为下一个位置的 “左侧总和” 做准备。
  -右边界判断（下标 b-1，`nums[b-1] == 0`）
    - 右边界的 “右侧总和`R`” 为 0（无右侧元素），仅需关注左侧总和`l`（此时`l`已更新为`nums[0..b-2]`的和）：
        - 若`l == 0`（左侧无需要归零的元素）：初始方向左 / 右均有效，`ans += 2`；
        - 若`l == 1`（左侧仅 1 个需归零的元素）：仅 1 种方向有效，`ans += 1`；
        - 其他`l`值：无有效方案，不加分。



### 代码实现



```python
class Solution:
    def countValidSelections(self, nums: List[int]) -> int:
        ans = 0
        b = len(nums)
        l,r = nums[0],sum(nums)-nums[0]
        if b == 1 and nums[0] == 0:
            return 2


        if nums[0] == 0:
            if r == 0:
                ans += 2
            elif r == 1:
                ans += 1

        for i in range(1,b-1):
            r -= nums[i]
            if nums[i] == 0:
                if l == r:
                    ans += 2
                elif abs(l-r) == 1:
                    ans += 1
            l += nums[i]
            
        if nums[b-1] == 0:
            if l == 0:
                ans += 2
            elif l == 1:
                ans += 1
        
        return ans
```

### 时空复杂度分析

- 时间复杂度：O (n)
    - `n`为数组`nums`的长度。
- 空间复杂度：O (1)
    - 仅使用常数个变量（`ans`、`b`、`l`、`r`、`i`），无额外数组或数据结构；

# 3346. 执行操作后元素的最高频率 I
><span style="color:rgb(251,193,45)">中等</span>
## 题目描述

给你一个整数数组 `nums` 和两个整数 `k` 和 `numOperations`。你必须对 `nums` 执行 `numOperations` 次操作，每次操作需满足以下条件：



1. 选择一个下标 `i`，且该下标在之前的操作中**没有被选择过**（每个下标最多操作一次）；

2. 将 `nums[i]` 增加范围 `[-k, k]` 中的一个整数（可增加负数、0 或正数，即 `nums[i]` 最终取值范围为 `[nums[i]-k, nums[i]+k]`）。

在执行完所有操作后，请返回 `nums` 中出现**频率最高**的元素的出现次数（频率指元素在数组中出现的次数）。

## 示例

### 示例 1



* **输入**：`nums = [1,4,5]`，`k = 1`，`numOperations = 2`

* **输出**：`2`

* **解释**：

1. 选择下标 1（未操作过），将 `nums[1]` 增加 0，数组变为 `[1, 4, 5]`；

2. 选择下标 2（未操作过），将 `nums[2]` 增加 -1，数组变为 `[1, 4, 4]`；

3. 最终数组中 `4` 出现 2 次，为最高频率，故返回 2。

### 示例 2



* **输入**：`nums = [5,11,20,20]`，`k = 5`，`numOperations = 1`

* **输出**：`2`

* **解释**：

1. 选择下标 1（未操作过），将 `nums[1]` 增加 0，数组仍为 `[5, 11, 20, 20]`；

2. 最终数组中 `20` 出现 2 次，为最高频率，故返回 2。

## 提示



* `1 <= nums.length <= 10^5`

* `1 <= nums[i] <= 10^5`

* `0 <= k <= 10^5`

* `0 <= numOperations <= nums.length`（操作次数不超过数组长度，保证每次操作都能选到未操作过的下标）









***
***




## 解法一：排序 + 枚举 + 二分查找([官方题解](https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-i/solutions/3803630/zhi-xing-cao-zuo-hou-yuan-su-de-zui-gao-lk58w/?envType=daily-question&envId=2025-10-24))

### 解题思路

首先处理约束条件 `numOperations`。虽然题意要求恰好操作 `numOperations` 次，但由于可以选定若干个元素加 0 且 `numOperations` 小于 `nums` 的长度，这实际上意味着可以至多选择 `numOperations` 个元素，使它们在 `[-k,k]` 范围内调整。

考虑枚举目标众数。设 `nums` 的最小值和最大值分别为 `num_min`，`num_max`，显然有枚举区间 `[num_min, num_max]`。

假设对于每一个 `m_i`，都能算出最多有 `f_i` 个数能变为 `m_i`，那么将 `f_i` 作为 `ans_temp` 去更新全局 `ans`，由于答案一定存在于某个 `m_i` 中，此时正确性是显然的。

下面考虑如何计算 `f_i`。

对于每一个 `m_i`，首先考虑约束条件 `k`，易得只有 `[m_i - k, m_i + k]` 这个范围内的数才能变成 `m_i`，若对 `nums` 排序，很容易通过二分查找找到 `m_i - k` 和 `m_i + k` 在 `nums` 对应的下界元素（第一个大于等于 `m_i - k` 的元素，下标记为 `l`）和上界元素（最后一个小于等于 `m_i + k` 的元素，下标记为 `r`）。

这意味着任意 `nums[i], i ∈ [l, r]` 都有机会消耗一次操作变为 `m_i`。为了满足 `numOperations` 的约束，同时使这个区间内的数尽可能多的变为 `m_i`，`f_i` 的值应该是区间长度和 `numOperations` 的较小值，即 `f_i = min(r - l + 1, numOperations)`。

还有最后一件事情需要考虑：如果我们枚举的 `m_i` 是 `nums` 中的某个数，那么不应该在这些数上浪费操作次数。因此我们还需要预处理出 `nums` 中每个数的出现次数。在最后计算 `f_i` 的时候加上它。设某个 `m_i` 的出现次数为 `count_i`，`f_i` 最终的计算方法为 `f_i = min(r - l + 1, numOperations + count_i)`。



### 代码实现
```python
class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        nums.sort()
        ans = 0
        num_count = {}
        last_num_index = 0
        for i in range(len(nums)):
            if nums[i] != nums[last_num_index]:
                num_count[nums[last_num_index]] = i - last_num_index
                ans = max(ans, i - last_num_index)
                last_num_index = i

        num_count[nums[last_num_index]] = len(nums) - last_num_index
        ans = max(ans, len(nums) - last_num_index)

        for i in range(nums[0], nums[-1] + 1):
            l = bisect.bisect_left(nums, i - k)
            r = bisect.bisect_right(nums, i + k) - 1
            if i in num_count:
                temp_ans = min(r - l + 1, num_count[i] + numOperations)
            else:
                temp_ans = min(r - l + 1, numOperations)
            ans = max(ans, temp_ans)

        return ans
```

### 时空复杂度

- 时间复杂度 O(max(nlogn,klogn))
    - 设 n 为 nums 的长度，且 0≤nums[i]≤k。排序需要 O(nlogn)，预处理需要 O(n)，枚举众数需要 O(klogn)，总时间复杂度为 O(max(nlogn,klogn))。


- 空间复杂度 O(n)














